/* tslint:disable */
/* eslint-disable */
/**
 * IONOS DBaaS PostgreSQL REST API
 * An enterprise-grade Database is provided as a Service (DBaaS) solution that can be managed through a browser-based \"Data Center Designer\" (DCD) tool or via an easy to use API.  The API allows you to create additional PostgreSQL database clusters or modify existing ones. It is designed to allow users to leverage the same power and flexibility found within the DCD visual tool. Both tools are consistent with their concepts and lend well to making the experience smooth and intuitive. 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration, DEFAULT_MAX_RETRIES, DEFAULT_MAX_WAIT_TIME } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, backOff, runRequest } from '../base';
// @ts-ignore
import { Database } from '../model';
// @ts-ignore
import { DatabaseList } from '../model';
// @ts-ignore
import { DatabaseResource } from '../model';
// @ts-ignore
import { ErrorResponse } from '../model';
/**
 * DatabasesApi - axios parameter creator
 * @export
 */
export const DatabasesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Deletes a single database
         * @summary Delete database
         * @param {string} clusterId The unique ID of the cluster.
         * @param {string} databasename The database name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databasesDelete: async (clusterId: string, databasename: string, options: any = {}): Promise<RequestArgs> => {
            if (clusterId === null || clusterId === undefined) {
                throw new RequiredError('clusterId','Required parameter clusterId was null or undefined when calling databasesDelete.');
            }
            if (databasename === null || databasename === undefined) {
                throw new RequiredError('databasename','Required parameter databasename was null or undefined when calling databasesDelete.');
            }
            const localVarPath = `/clusters/{clusterId}/databases/{databasename}`
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"databasename"}}`, encodeURIComponent(String(databasename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a single database
         * @summary Get database
         * @param {string} clusterId The unique ID of the cluster.
         * @param {string} databasename The database name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databasesGet: async (clusterId: string, databasename: string, options: any = {}): Promise<RequestArgs> => {
            if (clusterId === null || clusterId === undefined) {
                throw new RequiredError('clusterId','Required parameter clusterId was null or undefined when calling databasesGet.');
            }
            if (databasename === null || databasename === undefined) {
                throw new RequiredError('databasename','Required parameter databasename was null or undefined when calling databasesGet.');
            }
            const localVarPath = `/clusters/{clusterId}/databases/{databasename}`
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)))
                .replace(`{${"databasename"}}`, encodeURIComponent(String(databasename)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of databases
         * @summary List databases
         * @param {string} clusterId The unique ID of the cluster.
         * @param {number} [limit] The maximum number of elements to return. Use together with \&#39;offset\&#39; for pagination.
         * @param {number} [offset] The first element to return. Use together with \&#39;limit\&#39; for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databasesList: async (clusterId: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            if (clusterId === null || clusterId === undefined) {
                throw new RequiredError('clusterId','Required parameter clusterId was null or undefined when calling databasesList.');
            }
            const localVarPath = `/clusters/{clusterId}/databases`
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarApiKeyValue;
            }

            if ((limit === undefined) && (configuration !== undefined)) {
                limit = configuration.getDefaultParamValue('limit');
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if ((offset === undefined) && (configuration !== undefined)) {
                offset = configuration.getDefaultParamValue('offset');
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new database
         * @summary Create a database
         * @param {string} clusterId The unique ID of the cluster.
         * @param {Database} database a database to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databasesPost: async (clusterId: string, database: Database, options: any = {}): Promise<RequestArgs> => {
            if (clusterId === null || clusterId === undefined) {
                throw new RequiredError('clusterId','Required parameter clusterId was null or undefined when calling databasesPost.');
            }
            if (database === null || database === undefined) {
                throw new RequiredError('database','Required parameter database was null or undefined when calling databasesPost.');
            }
            const localVarPath = `/clusters/{clusterId}/databases`
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof database !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(database !== undefined ? database : {})
                : (database || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabasesApi - functional programming interface
 * @export
 */
export const DatabasesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Deletes a single database
         * @summary Delete database
         * @param {string} clusterId The unique ID of the cluster.
         * @param {string} databasename The database name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databasesDelete(clusterId: string, databasename: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const axiosArgs = await DatabasesApiAxiosParamCreator(configuration).databasesDelete(clusterId, databasename, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Retrieves a single database
         * @summary Get database
         * @param {string} clusterId The unique ID of the cluster.
         * @param {string} databasename The database name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databasesGet(clusterId: string, databasename: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseResource>> {
            const axiosArgs = await DatabasesApiAxiosParamCreator(configuration).databasesGet(clusterId, databasename, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Retrieves a list of databases
         * @summary List databases
         * @param {string} clusterId The unique ID of the cluster.
         * @param {number} [limit] The maximum number of elements to return. Use together with \&#39;offset\&#39; for pagination.
         * @param {number} [offset] The first element to return. Use together with \&#39;limit\&#39; for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databasesList(clusterId: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseList>> {
            const axiosArgs = await DatabasesApiAxiosParamCreator(configuration).databasesList(clusterId, limit, offset, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Create a new database
         * @summary Create a database
         * @param {string} clusterId The unique ID of the cluster.
         * @param {Database} database a database to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databasesPost(clusterId: string, database: Database, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseResource>> {
            const axiosArgs = await DatabasesApiAxiosParamCreator(configuration).databasesPost(clusterId, database, options);
            return runRequest(axiosArgs, configuration);
        },
    }
};

/**
 * DatabasesApi - factory interface
 * @export
 */
export const DatabasesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Deletes a single database
         * @summary Delete database
         * @param {string} clusterId The unique ID of the cluster.
         * @param {string} databasename The database name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databasesDelete(clusterId: string, databasename: string, options?: any): AxiosPromise<void> {
            return DatabasesApiFp(configuration).databasesDelete(clusterId, databasename, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a single database
         * @summary Get database
         * @param {string} clusterId The unique ID of the cluster.
         * @param {string} databasename The database name.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databasesGet(clusterId: string, databasename: string, options?: any): AxiosPromise<DatabaseResource> {
            return DatabasesApiFp(configuration).databasesGet(clusterId, databasename, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of databases
         * @summary List databases
         * @param {string} clusterId The unique ID of the cluster.
         * @param {number} [limit] The maximum number of elements to return. Use together with \&#39;offset\&#39; for pagination.
         * @param {number} [offset] The first element to return. Use together with \&#39;limit\&#39; for pagination.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databasesList(clusterId: string, limit?: number, offset?: number, options?: any): AxiosPromise<DatabaseList> {
            return DatabasesApiFp(configuration).databasesList(clusterId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new database
         * @summary Create a database
         * @param {string} clusterId The unique ID of the cluster.
         * @param {Database} database a database to create
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databasesPost(clusterId: string, database: Database, options?: any): AxiosPromise<DatabaseResource> {
            return DatabasesApiFp(configuration).databasesPost(clusterId, database, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for databasesDelete operation in DatabasesApi.
 * @export
 * @interface DatabasesApiDatabasesDeleteRequest
 */
export interface DatabasesApiDatabasesDeleteRequest {
    /**
     * The unique ID of the cluster.
     * @type {string}
     * @memberof DatabasesApiDatabasesDelete
     */
    readonly clusterId: string

    /**
     * The database name.
     * @type {string}
     * @memberof DatabasesApiDatabasesDelete
     */
    readonly databasename: string
}

/**
 * Request parameters for databasesGet operation in DatabasesApi.
 * @export
 * @interface DatabasesApiDatabasesGetRequest
 */
export interface DatabasesApiDatabasesGetRequest {
    /**
     * The unique ID of the cluster.
     * @type {string}
     * @memberof DatabasesApiDatabasesGet
     */
    readonly clusterId: string

    /**
     * The database name.
     * @type {string}
     * @memberof DatabasesApiDatabasesGet
     */
    readonly databasename: string
}

/**
 * Request parameters for databasesList operation in DatabasesApi.
 * @export
 * @interface DatabasesApiDatabasesListRequest
 */
export interface DatabasesApiDatabasesListRequest {
    /**
     * The unique ID of the cluster.
     * @type {string}
     * @memberof DatabasesApiDatabasesList
     */
    readonly clusterId: string

    /**
     * The maximum number of elements to return. Use together with \&#39;offset\&#39; for pagination.
     * @type {number}
     * @memberof DatabasesApiDatabasesList
     */
    readonly limit?: number

    /**
     * The first element to return. Use together with \&#39;limit\&#39; for pagination.
     * @type {number}
     * @memberof DatabasesApiDatabasesList
     */
    readonly offset?: number
}

/**
 * Request parameters for databasesPost operation in DatabasesApi.
 * @export
 * @interface DatabasesApiDatabasesPostRequest
 */
export interface DatabasesApiDatabasesPostRequest {
    /**
     * The unique ID of the cluster.
     * @type {string}
     * @memberof DatabasesApiDatabasesPost
     */
    readonly clusterId: string

    /**
     * a database to create
     * @type {Database}
     * @memberof DatabasesApiDatabasesPost
     */
    readonly database: Database
}

/**
 * DatabasesApi - object-oriented interface
 * @export
 * @class DatabasesApi
 * @extends {BaseAPI}
 */
export class DatabasesApi extends BaseAPI {
    /**
     * Deletes a single database
     * @summary Delete database
     * @param {DatabasesApiDatabasesDeleteRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public databasesDelete(requestParameters: DatabasesApiDatabasesDeleteRequest, options?: any) {
        return DatabasesApiFp(this.configuration).databasesDelete(requestParameters.clusterId, requestParameters.databasename, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a single database
     * @summary Get database
     * @param {DatabasesApiDatabasesGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public databasesGet(requestParameters: DatabasesApiDatabasesGetRequest, options?: any) {
        return DatabasesApiFp(this.configuration).databasesGet(requestParameters.clusterId, requestParameters.databasename, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of databases
     * @summary List databases
     * @param {DatabasesApiDatabasesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public databasesList(requestParameters: DatabasesApiDatabasesListRequest, options?: any) {
        return DatabasesApiFp(this.configuration).databasesList(requestParameters.clusterId, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new database
     * @summary Create a database
     * @param {DatabasesApiDatabasesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabasesApi
     */
    public databasesPost(requestParameters: DatabasesApiDatabasesPostRequest, options?: any) {
        return DatabasesApiFp(this.configuration).databasesPost(requestParameters.clusterId, requestParameters.database, options).then((request) => request(this.axios, this.basePath));
    }
}
