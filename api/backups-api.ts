/* tslint:disable */
/* eslint-disable */
/**
 * IONOS DBaaS PostgreSQL REST API
 * An enterprise-grade Database is provided as a Service (DBaaS) solution that can be managed through a browser-based \"Data Center Designer\" (DCD) tool or via an easy to use API.  The API allows you to create additional PostgreSQL database clusters or modify existing ones. It is designed to allow users to leverage the same power and flexibility found within the DCD visual tool. Both tools are consistent with their concepts and lend well to making the experience smooth and intuitive. 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration, DEFAULT_MAX_RETRIES, DEFAULT_MAX_WAIT_TIME } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError, backOff, runRequest } from '../base';
// @ts-ignore
import { BackupResponse } from '../model';
// @ts-ignore
import { ClusterBackupList } from '../model';
// @ts-ignore
import { ErrorResponse } from '../model';
/**
 * BackupsApi - axios parameter creator
 * @export
 */
export const BackupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of all backups of the given PostgreSQL cluster.
         * @summary List backups of cluster
         * @param {string} clusterId The unique ID of the cluster.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterBackupsGet: async (clusterId: string, options: any = {}): Promise<RequestArgs> => {
            if (clusterId === null || clusterId === undefined) {
                throw new RequiredError('clusterId','Required parameter clusterId was null or undefined when calling clusterBackupsGet.');
            }
            const localVarPath = `/clusters/{clusterId}/backups`
                .replace(`{${"clusterId"}}`, encodeURIComponent(String(clusterId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a PostgreSQL cluster backup by using its ID. This value can be found when you GET a list of PostgreSQL cluster backups. 
         * @summary Fetch a cluster backup
         * @param {string} backupId The unique ID of the backup.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clustersBackupsFindById: async (backupId: string, options: any = {}): Promise<RequestArgs> => {
            if (backupId === null || backupId === undefined) {
                throw new RequiredError('backupId','Required parameter backupId was null or undefined when calling clustersBackupsFindById.');
            }
            const localVarPath = `/clusters/backups/{backupId}`
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a list of all PostgreSQL cluster backups.
         * @summary List cluster backups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clustersBackupsGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/clusters/backups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarRequestOptions["auth"] = { username: configuration.username, password: configuration.password };
            }

            // authentication tokenAuth required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("Authorization")
                    : await configuration.apiKey;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarApiKeyValue;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BackupsApi - functional programming interface
 * @export
 */
export const BackupsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Retrieves a list of all backups of the given PostgreSQL cluster.
         * @summary List backups of cluster
         * @param {string} clusterId The unique ID of the cluster.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clusterBackupsGet(clusterId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterBackupList>> {
            const axiosArgs = await BackupsApiAxiosParamCreator(configuration).clusterBackupsGet(clusterId, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Retrieve a PostgreSQL cluster backup by using its ID. This value can be found when you GET a list of PostgreSQL cluster backups. 
         * @summary Fetch a cluster backup
         * @param {string} backupId The unique ID of the backup.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clustersBackupsFindById(backupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BackupResponse>> {
            const axiosArgs = await BackupsApiAxiosParamCreator(configuration).clustersBackupsFindById(backupId, options);
            return runRequest(axiosArgs, configuration);
        },
        /**
         * Retrieves a list of all PostgreSQL cluster backups.
         * @summary List cluster backups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async clustersBackupsGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClusterBackupList>> {
            const axiosArgs = await BackupsApiAxiosParamCreator(configuration).clustersBackupsGet(options);
            return runRequest(axiosArgs, configuration);
        },
    }
};

/**
 * BackupsApi - factory interface
 * @export
 */
export const BackupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Retrieves a list of all backups of the given PostgreSQL cluster.
         * @summary List backups of cluster
         * @param {string} clusterId The unique ID of the cluster.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clusterBackupsGet(clusterId: string, options?: any): AxiosPromise<ClusterBackupList> {
            return BackupsApiFp(configuration).clusterBackupsGet(clusterId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a PostgreSQL cluster backup by using its ID. This value can be found when you GET a list of PostgreSQL cluster backups. 
         * @summary Fetch a cluster backup
         * @param {string} backupId The unique ID of the backup.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clustersBackupsFindById(backupId: string, options?: any): AxiosPromise<BackupResponse> {
            return BackupsApiFp(configuration).clustersBackupsFindById(backupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a list of all PostgreSQL cluster backups.
         * @summary List cluster backups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        clustersBackupsGet(options?: any): AxiosPromise<ClusterBackupList> {
            return BackupsApiFp(configuration).clustersBackupsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for clusterBackupsGet operation in BackupsApi.
 * @export
 * @interface BackupsApiClusterBackupsGetRequest
 */
export interface BackupsApiClusterBackupsGetRequest {
    /**
     * The unique ID of the cluster.
     * @type {string}
     * @memberof BackupsApiClusterBackupsGet
     */
    readonly clusterId: string
}

/**
 * Request parameters for clustersBackupsFindById operation in BackupsApi.
 * @export
 * @interface BackupsApiClustersBackupsFindByIdRequest
 */
export interface BackupsApiClustersBackupsFindByIdRequest {
    /**
     * The unique ID of the backup.
     * @type {string}
     * @memberof BackupsApiClustersBackupsFindById
     */
    readonly backupId: string
}

/**
 * BackupsApi - object-oriented interface
 * @export
 * @class BackupsApi
 * @extends {BaseAPI}
 */
export class BackupsApi extends BaseAPI {
    /**
     * Retrieves a list of all backups of the given PostgreSQL cluster.
     * @summary List backups of cluster
     * @param {BackupsApiClusterBackupsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public clusterBackupsGet(requestParameters: BackupsApiClusterBackupsGetRequest, options?: any) {
        return BackupsApiFp(this.configuration).clusterBackupsGet(requestParameters.clusterId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a PostgreSQL cluster backup by using its ID. This value can be found when you GET a list of PostgreSQL cluster backups. 
     * @summary Fetch a cluster backup
     * @param {BackupsApiClustersBackupsFindByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public clustersBackupsFindById(requestParameters: BackupsApiClustersBackupsFindByIdRequest, options?: any) {
        return BackupsApiFp(this.configuration).clustersBackupsFindById(requestParameters.backupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a list of all PostgreSQL cluster backups.
     * @summary List cluster backups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BackupsApi
     */
    public clustersBackupsGet(options?: any) {
        return BackupsApiFp(this.configuration).clustersBackupsGet(options).then((request) => request(this.axios, this.basePath));
    }
}
